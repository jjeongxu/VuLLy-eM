{"messages": [{"role": "system", "content": "I want you to act as a vulnerability detection model."}, {"role": "user", "content": "Check if the following code has vulnerabilities.\n```static int create_one_file(struct apply_state *state,\n\t\t\t   char *path,\n\t\t\t   unsigned mode,\n\t\t\t   const char *buf,\n\t\t\t   unsigned long size)\n{\n\tint res;\n\n\tif (state->cached)\n\t\treturn 0;\n\n\tres = try_create_file(state, path, mode, buf, size);\n\tif (res < 0)\n\t\treturn -1;\n\tif (!res)\n\t\treturn 0;\n\n\tif (errno == ENOENT) {\n\t\tif (safe_create_leading_directories_no_share(path))\n\t\t\treturn 0;\n\t\tres = try_create_file(state, path, mode, buf, size);\n\t\tif (res < 0)\n\t\t\treturn -1;\n\t\tif (!res)\n\t\t\treturn 0;\n\t}\n\n\tif (errno == EEXIST || errno == EACCES) {\n\t\t/* We may be trying to create a file where a directory\n\t\t * used to be.\n\t\t */\n\t\tstruct stat st;\n\t\tif (!lstat(path, &st) && (!S_ISDIR(st.st_mode) || !rmdir(path)))\n\t\t\terrno = EEXIST;\n\t}\n\n\tif (errno == EEXIST) {\n\t\tunsigned int nr = getpid();\n\n\t\tfor (;;) {\n\t\t\tchar newpath[PATH_MAX];\n\t\t\tmksnpath(newpath, sizeof(newpath), \"%s~%u\", path, nr);\n\t\t\tres = try_create_file(state, newpath, mode, buf, size);\n\t\t\tif (res < 0)\n\t\t\t\treturn -1;\n\t\t\tif (!res) {\n\t\t\t\tif (!rename(newpath, path))\n\t\t\t\t\treturn 0;\n\t\t\t\tunlink_or_warn(newpath);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno != EEXIST)\n\t\t\t\tbreak;\n\t\t\t++nr;\n\t\t}\n\t}\n\treturn error_errno(_(\"unable to write file '%s' mode %o\"),\n\t\t\t   path, mode);\n}```"}, {"role": "assistant", "content": "1"}]}
{"messages": [{"role": "system", "content": "I want you to act as a vulnerability detection model."}, {"role": "user", "content": "Check if the following code has vulnerabilities.\n```static ssize_t write_mem(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t written, sz;\n\tunsigned long copied;\n\tvoid *ptr;\n\n\tif (p != *ppos)\n\t\treturn -EFBIG;\n\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\n\twritten = 0;\n\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\t/* we don't have page 0 mapped on sparc and m68k.. */\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\t/* Hmm. Do something? */\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n#endif\n\n\twhile (count > 0) {\n\t\tsz = size_inside_page(p, count);\n\n\t\tif (!range_is_allowed(p >> PAGE_SHIFT, sz))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n\t\t * it must also be accessed uncached by the kernel or data\n\t\t * corruption may occur.\n\t\t */\n\t\tptr = xlate_dev_mem_ptr(p);\n\t\tif (!ptr) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tcopied = copy_from_user(ptr, buf, sz);\n\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\tif (copied) {\n\t\t\twritten += sz - copied;\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n\n\t*ppos += written;\n\treturn written;\n}```"}, {"role": "assistant", "content": "1"}]}
{"messages": [{"role": "system", "content": "I want you to act as a vulnerability detection model."}, {"role": "user", "content": "Check if the following code has vulnerabilities.\n```struct dir_iterator *dir_iterator_begin(const char *path, unsigned int flags)\n{\n\tstruct dir_iterator_int *iter = xcalloc(1, sizeof(*iter));\n\tstruct dir_iterator *dir_iterator = &iter->base;\n\tint saved_errno;\n\n\tstrbuf_init(&iter->base.path, PATH_MAX);\n\tstrbuf_addstr(&iter->base.path, path);\n\n\tALLOC_GROW(iter->levels, 10, iter->levels_alloc);\n\titer->levels_nr = 0;\n\titer->flags = flags;\n\n\t/*\n\t * Note: stat already checks for NULL or empty strings and\n\t * inexistent paths.\n\t */\n\tif (stat(iter->base.path.buf, &iter->base.st) < 0) {\n\t\tsaved_errno = errno;\n\t\tgoto error_out;\n\t}\n\n\tif (!S_ISDIR(iter->base.st.st_mode)) {\n\t\tsaved_errno = ENOTDIR;\n\t\tgoto error_out;\n\t}\n\n\treturn dir_iterator;\n\nerror_out:\n\tdir_iterator_abort(dir_iterator);\n\terrno = saved_errno;\n\treturn NULL;\n}```"}, {"role": "assistant", "content": "1"}]}
